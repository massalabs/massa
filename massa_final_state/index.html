<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Copyright (c) 2022 MASSA LABS info@massa.net"><title>massa_final_state - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="massa_final_state" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../massa_final_state/index.html">massa_final_state</a><span class="version">2.4.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">massa_final_state</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/massa_final_state/lib.rs.html#1-111">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Copyright (c) 2022 MASSA LABS <a href="mailto:info@massa.net">info@massa.net</a></p>
<h2 id="general-description"><a class="doc-anchor" href="#general-description">Â§</a>General description</h2>
<p>This crate implements a final state that encompasses a final ledger and asynchronous message pool.
Nodes store only one copy of this final state which is very large
(the copy is attached to the output of the last executed final slot),
and apply speculative changes on it to deduce its value at a non-final slot
(see <code>massa-execution-exports</code> crate for more details).
Nodes joining the network need to bootstrap this state.</p>
<h2 id="architecture"><a class="doc-anchor" href="#architecture">Â§</a>Architecture</h2><h3 id="final_staters"><a class="doc-anchor" href="#final_staters">Â§</a><code>final_state.rs</code></h3>
<p>Defines the <code>FinalState</code> that matches that represents the state of the node at
the latest executed final slot. It contains the final ledger and the asynchronous event pool.
It can be manipulated using <code>StateChanges</code> (see <code>state_changes.rs</code>).
The <code>FinalState</code> is bootstrapped using tooling available in bootstrap.rs</p>
<h3 id="state_changesrs"><a class="doc-anchor" href="#state_changesrs">Â§</a><code>state_changes.rs</code></h3>
<p>Represents a list of changes the final state.
It can be modified, combined or applied to the final ledger.</p>
<h3 id="executed_opsrs"><a class="doc-anchor" href="#executed_opsrs">Â§</a><code>executed_ops.rs</code></h3>
<p>Defines a structure to list and prune previously executed operations.
Used to detect operation reuse.</p>
<h3 id="bootstraprs"><a class="doc-anchor" href="#bootstraprs">Â§</a><code>bootstrap.rs</code></h3>
<p>Provides serializable structures and tools for bootstrapping the final state.</p>
<h3 id="test-exports"><a class="doc-anchor" href="#test-exports">Â§</a>Test exports</h3>
<p>When the crate feature <code>test-exports</code> is enabled, tooling useful for test-exports purposes is exported.
See <code>test_exports/mod.rs</code> for details.</p>
<h2 id="network-restart-documentation"><a class="doc-anchor" href="#network-restart-documentation">Â§</a>Network restart documentation</h2><h3 id="goals-of-the-network-restart"><a class="doc-anchor" href="#goals-of-the-network-restart">Â§</a>Goals of the network restart</h3>
<p>If the blockchain crashes (corrupted / attacked ledger, all nodes crash, etc.) and we want to keep the same main parameters of the network (same <code>GENESIS_TIMESTAMP</code>, same ledger, same final_state, etc.), then we can restart the network.</p>
<p><strong>ONE</strong> node should restart from a snapshot (which is just the RocksDB ledger, read as usual), and the other nodes should bootstrap from it.</p>
<h3 id="command-line"><a class="doc-anchor" href="#command-line">Â§</a>Command line</h3><div class="example-wrap"><pre class="language-sh"><code>cargo run --release -- --restart-from-snapshot-at-period 200
</code></pre></div>
<p>Means: the node will restart from the ledger and final_state on disk (usual path in the config). Block production will start once the period given in args is reached (here, 200).</p>
<h3 id="scenario"><a class="doc-anchor" href="#scenario">Â§</a>Scenario</h3>
<ol>
<li>At period 40, the network crashes.</li>
<li>We restart one node N0, at the time of period 80, with <code>cargo run --release -- --restart-from-snapshot-at-period 200</code></li>
<li>We start one other node N1, at the time of period 100, with <code>cargo run --release</code></li>
<li>The node N1 will bootstrap from N0. No blocks are produced yet.</li>
<li>At the time of period 200, block production starts again.</li>
</ol>
<h3 id="additional-notes"><a class="doc-anchor" href="#additional-notes">Â§</a>Additional notes</h3><h4 id="why-is-block-production-delayed"><a class="doc-anchor" href="#why-is-block-production-delayed">Â§</a>Why is block production delayed?</h4>
<p>In order to give time to all nodes to rejoin the network after a crash and bootstrap. If we donâ€™t give them the time, their rolls would be sold because most stakers would have a lot of block miss.</p>
<h4 id="in-sandbox"><a class="doc-anchor" href="#in-sandbox">Â§</a>In sandbox</h4>
<p>Sandbox feature can be enabled. For instance, here is a test scenario:</p>
<ol>
<li>Run the node as usual: <code>cargo run --release --features sandbox</code></li>
<li>Make transaction, buy rolls, etc.</li>
<li>Shut down the node at slot S_0.</li>
<li>Restart the network: <code>cargo run --release --features sandbox --restart-from-snapshot-at-period S_1</code></li>
</ol>
<p>Here, the network will restart, and the network will start producing blocks again 10 seconds after launch.</p>
<p><strong>/!\ This means that the genesis timestamp will be different between runs, but it should not matter in most cases.</strong></p>
<h4 id="backups"><a class="doc-anchor" href="#backups">Â§</a>Backups</h4>
<p>By default, the network restarts from the state associated with the last final slot before the shutdown.
However, we may sometimes want to recover from an earlier state (e.g. if an attacker stole 50% of all Massa, we want to restart with the state before the attack.
We use RocksDB checkpoint system to save the state at regular interval (see the <code>ledger_backup_periods_interval</code> in the <code>massa-node</code> config).
Backups for <code>Slot {period, thread}</code> are stored in <code>massa &gt; massa-node &gt; storage &gt; ledger &gt; rocks_db_backup &gt; backup_[period]_[thread]</code>
Backups are hard links of the rocks_db, so the overhead of storing them should be minimal.
To recover from a backup, simply replace the contents of the rocks_db folder by the contents of the target backup folder.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="config/index.html" title="mod massa_final_state::config">config</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Copyright (c) 2022 MASSA LABS <a href="mailto:info@massa.net">info@massa.net</a>
This file defines a configuration structure containing all settings for final state management</div></li><li><div class="item-name"><a class="mod" href="controller_trait/index.html" title="mod massa_final_state::controller_trait">controller_trait</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod massa_final_state::error">error</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Copyright (c) 2022 MASSA LABS <a href="mailto:info@massa.net">info@massa.net</a>
This file defines all error types for final state management</div></li><li><div class="item-name"><a class="mod" href="final_state/index.html" title="mod massa_final_state::final_state">final_state</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Copyright (c) 2022 MASSA LABS <a href="mailto:info@massa.net">info@massa.net</a>
This file defines the final state of the node, which includes
the final ledger and asynchronous message pool that are kept at
the output of a given final slot (the latest executed final slot),
and need to be bootstrapped by nodes joining the network.</div></li><li><div class="item-name"><a class="mod" href="mapping_grpc/index.html" title="mod massa_final_state::mapping_grpc">mapping_grpc</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="state_changes/index.html" title="mod massa_final_state::state_changes">state_changes</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Copyright (c) 2022 MASSA LABS <a href="mailto:info@massa.net">info@massa.net</a>
This file provides structures representing changes to the final state</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.FinalState.html" title="struct massa_final_state::FinalState">FinalState</a></div><div class="desc docblock-short">Represents a final state <code>(ledger, async pool, executed_ops, executed_de and the state of the PoS)</code></div></li><li><div class="item-name"><a class="struct" href="struct.FinalStateConfig.html" title="struct massa_final_state::FinalStateConfig">FinalStateConfig</a></div><div class="desc docblock-short">Ledger configuration</div></li><li><div class="item-name"><a class="struct" href="struct.StateChanges.html" title="struct massa_final_state::StateChanges">StateChanges</a></div><div class="desc docblock-short">represents changes that can be applied to the execution state</div></li><li><div class="item-name"><a class="struct" href="struct.StateChangesDeserializer.html" title="struct massa_final_state::StateChangesDeserializer">StateChangesDeserializer</a></div><div class="desc docblock-short">Basic <code>StateChanges</code> deserializer</div></li><li><div class="item-name"><a class="struct" href="struct.StateChangesSerializer.html" title="struct massa_final_state::StateChangesSerializer">StateChangesSerializer</a></div><div class="desc docblock-short">Basic <code>StateChanges</code> serializer.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.FinalStateError.html" title="enum massa_final_state::FinalStateError">FinalStateError</a></div><div class="desc docblock-short">Final state error</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.FinalStateController.html" title="trait massa_final_state::FinalStateController">FinalStateController</a></div><div class="desc docblock-short">Trait for final state controller.</div></li></ul></section></div></main></body></html>
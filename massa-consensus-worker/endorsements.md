# Endorsements

## Goal

Endorsements are included in a block's header. They are created by randomly selected endorsers chosen among the stakers (including the block creator) to endorse the block's parent in the same thread. The block's total fee and reward are split between the block creator, the endorsers, and the creator of the endorsed block.

With that mechanism it becomes harder to gain control of the network (you now have to control `endorsement_count + 1` draw to gain control over one block) and to reward stakers more frequently.

```ignore
pub struct BlockHeader {
    pub endorsements: Vec<Endorsement>,
    ..
}
```

## Endorsement structure

An endorsement is defined as follows:

```ignore
pub struct Endorsement {
    pub content: EndorsementContent,
    pub signature: Signature,
}

pub struct EndorsementContent {
    /// Public key of the endorser.
    pub sender_public_key: PublicKey,
    /// slot of endorsed block (= parent in the same thread) (can be different that previous slot in the same thread)
    pub slot: Slot,
    /// endorsement index inside the block
    pub index: u32,
    /// hash of endorsed block (= parent in the same thread)
    pub endorsed_block: BlockId,
}
```

The endorser is selected to create an endorsement at a specific (slot, endorsement_index). To be included in a specif block, endorsed_block has to match that block's parent in the same thread, and slot has to match that parent's slot. The signature is produced signing the header_content with the sender_public_key.

## Endorsement production

Endorsements are automatically produced every time block db changed, if the slot hasn't already been endorsed, if it is at most one period before the last slot, and if a staking address of the node has been selected. Created endorsements are sent to the endorsement pool.

## Endorsement propagation

Once an endorsement is created by consensus, it is sent to the endorsement pool, where it is stored waiting for a request from consensus. Then it is sent to protocol and to every node that we don't know if it already has that endorsement. On the other hand, when receiving an endorsement from the network, protocol notes which node sent it, checks the signature and send it to the endorsement pool.

The endorsement pool is pruned if it reaches a max size and when new slots are becoming final.

## Endorsement integration

When creating a block consensus asks pool for endorsements specifying :

-   target_slot: the slot of the parent in the same thread of the block been produced
-   parent: that parent's BlockId
-   creators: the ordered addresses that were selected to create endorsements in for that slot

Pool responds with a vec of endorsement that is endorsement_count long or less, as some endorsements may be missing. That vec is ordered by endorsement index and when there are endorsement_count endorsement, that index should match the vec index.

## Reward computation

For each block reward R (constant or fee):

-   `1/(1 + config.endorsement_count)` to the block creator
-   For each included endorsement:
    -   `1/(3*(1 + config.endorsement_count))` to the block creator
    -   `1/(3*(1 + config.endorsement_count))` to the endorsed block's creator
    -   `1/(3*(1 + config.endorsement_count))` to the creator of the endorsement

Lossless rounding is done in favor of the block creator

### Example

Given :

-   addresses A, B, C in thread 0
-   block 1 at slot(1,0) created by A
-   operation O with a fee of 30 coins
-   block 2 at slot(2,0)
    -   created by B
    -   with operation O
    -   with following endorsements
        -   1 endorsement by A
        -   2 endorsement by B
        -   3 endorsement by C
    -   constant block reward of 70 coins

Let `share = 1 / (3*(1+endorsement_count)) = 1/(3*(1+6)) = 1/21 = 0.0476`.
Here we will use two digits precision.

The total reward generated by block 2 is 100 = 30 + 70 coins.

-   the part that goes to A is :
    -   `reward * endorsement_count * share = 100 * 6 * 1/21 = 28.57` because A created the endorsed block
    -   `+ reward * nb_created_endorsements * share = 100 * 1 * 1/21 = 4.76` because A created 1 endorsement
    -   `= 33.33`
-   the part that goes to C is :
    -   `reward * nb_created_endorsements * share = 100 * 3 * 1/21 = 14.28` because C created 3 endorsements
-   the part that goes to B is :
    -   `reward * 1/(1 + endorsement_count) = 100 * 1/(1+6) = 14.28` because B created the block
    -   `+ reward * nb_created_endorsements * share = 100 *2 * 1/21 = 9.52` because B created 2 endorsements
    -   `+ reward * endorsement_count * share = 100 * 6 * 1/21 = 28.57` because B included 6 endorsements
    -   `+ rounding`
    -   `= reward - other_stakers_parts`
    -   `= 52.39`

## Fitness

The fitness of a block is `(1 + number_of_included_endorsements)`

use crate::async_msg_id::{AsyncMessageId, AsyncMessageIdSerializer};
use crate::deferred_calls::DeferredCallId;
use crate::{address::Address, block_id::BlockId, operation::OperationId, slot::Slot};
use massa_serialization::Serializer;
use serde::{Deserialize, Serialize};
use std::cmp::Ordering;
use std::{collections::VecDeque, fmt::Display};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
/// By product of a byte code execution
pub struct SCOutputEvent {
    /// context generated by the execution context
    pub context: EventExecutionContext,
    /// json data string
    pub data: String,
}

impl PartialOrd for SCOutputEvent {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for SCOutputEvent {
    fn cmp(&self, other: &Self) -> Ordering {
        (self.context.slot, self.context.index_in_slot)
            .cmp(&(other.context.slot, other.context.index_in_slot))
    }
}

impl Display for SCOutputEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "Context: {}", self.context)?;
        writeln!(f, "Data: {}", self.data)
    }
}

/// Context of the event (not generated by the user)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct EventExecutionContext {
    /// when was it generated
    pub slot: Slot,
    /// block id if there was a block at that slot
    pub block: Option<BlockId>,
    /// if the event was generated during a read only execution
    pub read_only: bool,
    /// index of the event in the slot
    pub index_in_slot: u64,
    /// most recent at the end
    pub call_stack: VecDeque<Address>,
    /// origin operation id
    pub origin_operation_id: Option<OperationId>,
    /// if the event is final
    pub is_final: bool,
    /// if the sc that emitted this event failed
    pub is_error: bool,
    /// the deferred call id that is currently being executed
    pub deferred_call_id: Option<DeferredCallId>,
    /// the async message id that is currently being executed
    pub async_msg_id: Option<AsyncMessageId>,
}

impl Display for EventExecutionContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "Slot: {} at index: {}", self.slot, self.index_in_slot)?;

        writeln!(
            f,
            "{}",
            if self.read_only {
                "Read only execution"
            } else {
                "On chain execution"
            }
        )?;
        if let Some(id) = self.block {
            writeln!(f, "Block id: {}", id)?;
        }
        if let Some(id) = self.origin_operation_id {
            writeln!(f, "Origin operation id: {}", id)?;
        }
        if let Some(id) = &self.deferred_call_id {
            writeln!(f, "Deferred call id: {}", id)?;
        }
        if let Some(id) = self.async_msg_id {
            let serializer = AsyncMessageIdSerializer::new();
            let mut serialized = Vec::new();
            serializer.serialize(&id, &mut serialized).unwrap();
            writeln!(
                f,
                "Async message id: {}",
                bs58::encode(serialized).into_string()
            )?;
        }
        writeln!(
            f,
            "Call stack: {}",
            self.call_stack
                .iter()
                .map(|a| format!("{}", a))
                .collect::<Vec<_>>()
                .join(",")
        )
    }
}

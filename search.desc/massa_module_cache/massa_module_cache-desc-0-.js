searchState.loadedDescShard("massa_module_cache", 0, "Module caching saves compiled <code>massa-sc-runtime</code> modules for …\nDelta key formatting macro\nModule key formatting macro\nReturns the argument unchanged.\nGas costs used to:\nPath to the hard drive cache storage\nMaximum number of entries we want to keep in the HD cache\nCalls <code>U::from(self)</code>.\nMaximum number of entries we want to keep in the LRU cache\nMaximum length of a module\nAmount of entries removed when <code>hd_cache_size</code> is reached\nCache controller of compiled runtime modules\n<code>LruMap</code> specialization for <code>PreHashed</code> keys\nCache config. See <code>CacheConfig</code> documentation for more …\nInternal function to compile and build <code>ModuleInfo</code>\nReturns the argument unchanged.\nDisk stored cache. See the <code>HDCache</code> documentation for more …\nCalls <code>U::from(self)</code>.\nLoad a cached module for execution and check its validity …\nLoad a cached module for execution\nLoad a temporary module from arbitrary bytecode. Also …\nRAM stored LRU cache. See <code>LRUCache</code> documentation for more …\nCreates a new <code>ModuleCache</code>\nSave a new or an already existing module in the cache\nSet the initialization cost of a cached module\nSet a cached module as invalid\nCache error\nLoad error: {0}\nVM error: {0}\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRocksDB database\nHow many entries are in the db. Count is initialized at …\nReturns the argument unchanged.\nRetrieve a module\nInsert a new module in the cache\nCalls <code>U::from(self)</code>.\nMaximum number of entries we want to keep in the db. When …\nModule metadata deserializer\nModule metadata serializer\nCreate a new HDCache\nSets the initialization cost of a given module separately\nSets a given module as invalid\nTry to remove as much as <code>self.amount_to_snip</code> entries from …\nHow many entries are removed when <code>entry_count</code> reaches …\nRAM stored LRU cache. The LRU caching scheme is to remove …\n<code>LruMap</code> specialization for <code>PreHashed</code> keys\nReturns the argument unchanged.\nIf the module is contained in the cache:\nSave a module in the LRU cache\nCalls <code>U::from(self)</code>.\nCreate a new <code>LRUCache</code> with the given size\nSet the initialization cost of a LRU cached module\nSet a module as invalid\nMain type\nMetadata type\nMetadata deserializer\nMetadata ID type\nMetadata serializer\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")